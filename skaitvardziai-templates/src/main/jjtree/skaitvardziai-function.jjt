options {
	UNICODE_INPUT = true;
	STATIC = false;
	
	MULTI=false;
	NODE_PREFIX="";
	
	NODE_SCOPE_HOOK = false;
}

PARSER_BEGIN(SkaitvardziaiFunctionParser)

package eu.vytenis.parser;

@SuppressWarnings({"serial", "unused"})
public class SkaitvardziaiFunctionParser {}

PARSER_END(SkaitvardziaiFunctionParser)


SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN: {
  < NULL: "null" >
  |
  < #LETTER: ["a" - "z", "A" - "Z", "_"] >
  |
  < #DIGIT : ["0" - "9"] >
  |
  < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
}


TOKEN: {
	< #STRING_LITERAL_DOUBLE_QUOTED: "\"" (~["\""])* "\"" >
	|
	< #STRING_LITERAL_SINGLE_QUOTED: "'" (~["'"])* "'" >
	|
	< STRING_LITERAL: (<STRING_LITERAL_SINGLE_QUOTED> | <STRING_LITERAL_DOUBLE_QUOTED>) >
  
}

TOKEN: {
	<INTEGER_LITERAL: <DIGIT> (<DIGIT>)* >
}

SimpleNode FunctionCall() : {} {
	Identifier() "(" Arguments() ")" { return jjtThis; }
}

void Identifier() : {Token value;} {
	value = <IDENTIFIER> {jjtThis.value = value;}
}

void Arguments() : {} {
	Argument() ( "," Argument() )*
}

void Argument() : {} {
	LOOKAHEAD(2)
	FractionLiteral() | IntegerLiteral() | StringLiteral() 
}

void IntegerLiteral() : {Token value;} {
	value = <INTEGER_LITERAL> {jjtThis.value = value;}
}

void StringLiteral() : {Token value;} {
	value = <STRING_LITERAL> {jjtThis.value = value;}
}

void FractionLiteral() : {} {
	IntegerLiteral() "/" IntegerLiteral()
}

