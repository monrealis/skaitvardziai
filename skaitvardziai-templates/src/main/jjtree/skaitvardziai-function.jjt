options {
	UNICODE_INPUT = true;
	STATIC = false;
	
	MULTI=false;
	NODE_PREFIX="";
	
	NODE_SCOPE_HOOK = false;
}

PARSER_BEGIN(SkaitvardziaiFunctionParser)

package eu.vytenis.parser;

@SuppressWarnings({"serial", "unused"})
public class SkaitvardziaiFunctionParser {}

PARSER_END(SkaitvardziaiFunctionParser)


SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN: {
  < NULL: "null" >
  |
  < #LETTER: ["a" - "z", "A" - "Z", "_"] >
  |
  < #DIGIT : ["0" - "9"] >
  |
  < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
}


TOKEN: {
	< #STRING_LITERAL_DOUBLE_QUOTED: "\"" (~["\""])* "\"" >
	|
	< #STRING_LITERAL_SINGLE_QUOTED: "'" (~["'"])* "'" >
	|
	< STRING_LITERAL: (<STRING_LITERAL_SINGLE_QUOTED> | <STRING_LITERAL_DOUBLE_QUOTED>) >
  
}

TOKEN: {
	<NONNEGATIVE_INTEGER_LITERAL: <DIGIT> (<DIGIT>)* >
}

SimpleNode FunctionCall() : {} {
	Identifier() "(" [Arguments()] ")" { return jjtThis; }
}

void Identifier() : {Token value;} {
	value = <IDENTIFIER> {jjtThis.value = value;}
}

void Arguments() : {} {
	Argument() ( "," Argument() )*
}

void Argument() : {} {
	LOOKAHEAD(3)
	Fraction() | Integer() | String() 
}

void Integer() : {} {
	[Minus()] NonnegativeInteger()
}

void NonnegativeInteger() : {Token value;} {
	value = <NONNEGATIVE_INTEGER_LITERAL> {jjtThis.value = value;}
}

void String() : {Token value;} {
	value = <STRING_LITERAL> {jjtThis.value = value;}
}

void Fraction() : {} {
	Integer() "/" Integer()
}

void Minus() : {} {
	"-"
}

